# 第一章 并查集 hash 布隆过滤器

## hash 函数

* 输入域无限，输出域有限。例如MD5, 一个字符串输入后会输出一个`0~2**64-1`的一个数字
* 不引入任何随机的映射，对相同输入，必定有相同输出。同样的，不同输入可能导致相同的输出。对相同的输出，叫做hash碰撞。
* 大量输入，不同的点在映射过程中，对每一个映射结果出现的概率是等值的。此时的均匀性和输入规律等等都无关。

### hash分流

* hash函数同样的函数可以得到相同的输出，你对大文件分流的时候，对多少个文件，基本是均匀分布，且相同的文件只会存在同一种数据。

### hash表的实现

* 分配一个质数的桶，例如17
* 将一个值 hash 转换成桶的号码 存储之
* 如果碰撞，单链表后串
* 如果需要扩容，那么桶容量翻倍。但是需要重新迁移，此时迁移的代价是o(N)。
* 在使用的时候都可以认为hash表的增删改查的时候为O(1)。离线技术。
* C++可以用固定长度数组代替hash表。

#### 练习~实现插入、删除、getrandkey复杂度为O(1)

* map1(key, index)  map2(index, str)
* 你再删除的时候，删除最后一条记录，用最后一条记录删除本应该的那个位置的洞

## 布隆过滤器

* 黑名单过滤，屏蔽url。但是这样的样本量很大，我们需要设置一个url黑名单。
* 存在失误率，url(黑)就一定是黑，但是对不属于的，也存在一定可能直接被屏蔽。
* 位图 bit arr[] 比特类型的数组 // 你可以用真实的int去拼 例如需要第x位的值 
*  (arr[x//32] & (1<<(x%32))) == 0 ? 0 : 1
* 此时空间就是/8的空间占用量
* 用k个hash函数去映射url 将K个位置描黑。形成表格。
* 对一个新的url 用k个hash函数去映射，有一个位置不是黑的，那么就不在黑名单。
* 但你的bit数组太短，这个时候会出现误报率过高。布隆过滤器只和样本量和失误率有关。
* 样本量n和预期失误率p可以确定布隆过滤器
  * m = -n*lnp / (ln2)**2
  * k = ln2 * m/n = 0.7m/n
  * `pTruth = (1-e**(-nk/m))**k`

## 一致性hash

* 传统服务器增减服务器的数据迁移代价特别高。
* 继承优点，且迁移代价足够低。
* 环形hash，首先依据服务器名字计算hash值，出现一个request，我让顺时针最近的服务器处理这个request
* 找hash值刚比数据hash大的，否则给第一个服务器
* 新增服务器~你只需要迁移两台，且某一个段落
* 利用虚拟节点技术可以解决负载不均更。例如三台服务器~每台服务器有1000个虚拟节点。真正在环上占位置的仅有虚拟节点。
* 利用这个技术甚至可以管理对服务器的负载。

## 并查集

* issameset(查询是否是一个集合里面的内容)  union(合并集合)方法
* issameset union复杂度都是O(1)
* 首先是元素均自己指向自己，一个元素最上层的节点，是一个相同的节点，那么我们称之为同一个集合。
* 合并，如果不是一个集合，把头找到，询问每个头下面有几个节点，把小的挂载在大的上。
* 打平，例如4-3-2-1 1是代表节点，你将4-1 3-1 2-1 这样直接打平

# 第二章

## 平衡树、左旋、右旋

* 所有的有序表，只是常数项不同。
* 对一般的查找树，节点x，直接add，相等不做处理，大往右滑，小就向左滑。遇到none插入
* 一般的查找树，删除x，四种情况：
  * 孤单的点，叶节点，直接删除
  * 没有左子树，有右子树
    * 直接让父节点指向x的右节点
  * 没有右子树有左子树，类似上
  * 拥有左右子树，找x的后继节点，用后继节点代替之。这个后继节点的孩子直接换至后继节点的位置。
  * 后继节点:
    * 有右子树，右子树最左
    * 没有右子树，一路向上，直到当前节点是节点父亲的左子树，那么这个父节点，就是后继节点
* 平衡树，左孩子的高度和右孩子的高度差不超过1

### 左旋，右旋

* 对某个节点x, 它的左孩子xl, 右孩子xr
  * 左旋, x向左倒, x的右孩子上位，此时x的右空出; 由于xr上位, xr的左子树为x, 那么xr的原左子树迁移至x的右
  * 类似左旋, 只是此次向右倒


* 头指针倒向哪里向哪里旋转。
* 左旋可以减小右树的高度，右旋可以减小左树的高度
* 插入的时候:
  * LL
    * 新节点插入在最左的节点下方导致不平衡
    * 右旋。
  * RR
    * 类似上面
  * LR
    * 把R转到头上去。头结点的~左子树先左旋，然后整体右旋
    * 插入的时候插入在左孩子的右子树上
  * RL
    * L转到头部
* 维持高度信息，向上依次将父节点的高度改对
* delete 谁替代了删除节点返回谁
  * 对于叶节点，直接从叶节点的父开始计算是否平衡
  * 如果有东西替代了父节点~
    * 从后继节点替代处开始~向parent出发判断是否平衡；新的右树最左开始向上到头一步一步判断平衡
    * 新的头部没有右子树，从当前点向上rebalance

## SB树

* 任何节点的高度不小于侄子的节点高度
* 自己写~基于这个~
* 不平衡类型:
  * 前提：节点x包含L和R两个孩子，L有L1和R1两个孩子 R有1L和1R两个孩子
  * L没有打过 1L 1R  R没打过 L1 R1
  * L1>R
    * 整棵树右旋，谁的左右两个孩子发生变化，那么对谁递归执行rebalance
  * 1R>L
    * 整棵树左旋，类似上递归
  * R1>R
    * R1 包含EF 你需要把R1转到头上去 L左旋，在进行整体右旋，R1就上去了
  * 1R>L
    * 类似上
* 删除节点，删掉就不管可。而且即便删除有限的K次，你的搜索时间复杂度依然是OlonN
* `#include <bits/stdc++.h>` 包含所有常用头文件