# 第一章 并查集 hash 布隆过滤器

## hash 函数

* 输入域无限，输出域有限。例如MD5, 一个字符串输入后会输出一个`0~2**64-1`的一个数字
* 不引入任何随机的映射，对相同输入，必定有相同输出。同样的，不同输入可能导致相同的输出。对相同的输出，叫做hash碰撞。
* 大量输入，不同的点在映射过程中，对每一个映射结果出现的概率是等值的。此时的均匀性和输入规律等等都无关。

### hash分流

* hash函数同样的函数可以得到相同的输出，你对大文件分流的时候，对多少个文件，基本是均匀分布，且相同的文件只会存在同一种数据。

### hash表的实现

* 分配一个质数的桶，例如17
* 将一个值 hash 转换成桶的号码 存储之
* 如果碰撞，单链表后串
* 如果需要扩容，那么桶容量翻倍。但是需要重新迁移，此时迁移的代价是o(N)。
* 在使用的时候都可以认为hash表的增删改查的时候为O(1)。离线技术。
* C++可以用固定长度数组代替hash表。

#### 练习~实现插入、删除、getrandkey复杂度为O(1)

* map1(key, index)  map2(index, str)
* 你再删除的时候，删除最后一条记录，用最后一条记录删除本应该的那个位置的洞

## 布隆过滤器

* 黑名单过滤，屏蔽url。但是这样的样本量很大，我们需要设置一个url黑名单。
* 存在失误率，url(黑)就一定是黑，但是对不属于的，也存在一定可能直接被屏蔽。
* 位图 bit arr[] 比特类型的数组 // 你可以用真实的int去拼 例如需要第x位的值 
*  (arr[x//32] & (1<<(x%32))) == 0 ? 0 : 1
* 此时空间就是/8的空间占用量
* 用k个hash函数去映射url 将K个位置描黑。形成表格。
* 对一个新的url 用k个hash函数去映射，有一个位置不是黑的，那么就不在黑名单。
* 但你的bit数组太短，这个时候会出现误报率过高。布隆过滤器只和样本量和失误率有关。
* 样本量n和预期失误率p可以确定布隆过滤器
  * m = -n*lnp / (ln2)**2
  * k = ln2 * m/n = 0.7m/n
  * `pTruth = (1-e**(-nk/m))**k`

## 一致性hash

* 传统服务器增减服务器的数据迁移代价特别高。
* 继承优点，且迁移代价足够低。
* 环形hash，首先依据服务器名字计算hash值，出现一个request，我让顺时针最近的服务器处理这个request
* 找hash值刚比数据hash大的，否则给第一个服务器
* 新增服务器~你只需要迁移两台，且某一个段落
* 利用虚拟节点技术可以解决负载不均更。例如三台服务器~每台服务器有1000个虚拟节点。真正在环上占位置的仅有虚拟节点。
* 利用这个技术甚至可以管理对服务器的负载。

## 并查集

* issameset(查询是否是一个集合里面的内容)  union(合并集合)方法
* issameset union复杂度都是O(1)
* 首先是元素均自己指向自己，一个元素最上层的节点，是一个相同的节点，那么我们称之为同一个集合。
* 合并，如果不是一个集合，把头找到，询问每个头下面有几个节点，把小的挂载在大的上。
* 打平，例如4-3-2-1 1是代表节点，你将4-1 3-1 2-1 这样直接打平